{
  "name": "bloomxx",
  "version": "0.0.2",
  "description": "bloom filters backed by xxhash",
  "main": "index.js",
  "directories": {
    "test": "./test",
    "lib": "./lib"
  },
  "scripts": {
    "test": "mocha -R spec test/*.js && mocha --require blanket -R travis-cov test/*.js",
    "test-cov": "mocha --require blanket -R travis-cov test/*.js",
    "coverage": "mocha --require blanket -R html-cov test/*.js > test/coverage.html"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/ceejbot/xx-bloom.git"
  },
  "bugs": {
    "url": "https://github.com/ceejbot/xx-bloom/issues"
  },
  "keywords": [
    "bloom",
    "bloom-filter",
    "counting-filter",
    "hash",
    "bitmap",
    "xxhash"
  ],
  "devDependencies": {
    "chai": "*",
    "mocha": "*",
    "blanket": "*",
    "travis-cov": "*"
  },
  "dependencies": {
    "xxhash": "*",
    "redis": "*",
    "hiredis": "*"
  },
  "optionalDependencies": {
    "redis": "*",
    "hiredis": "*"
  },
  "author": {
    "name": "C J Silverio",
    "email": "ceejceej@gmail.com"
  },
  "license": "MIT",
  "readme": "Yet another Bloom filter implementation for node.js. Everybody has to write one, as you know. Backed by [Xxhash](https://code.google.com/p/xxhash/) via [node-xxhash](https://github.com/mscdex/node-xxhash). Xxhash is a fast general-purpose hash, which is all a bloom filter needs. Three variations are provided: a straight Bloom filter, a counting filter (from which items can be removed), and a straight Bloom filter backed by redis. The first two have synchronous APIs. The redis one perforce requires callbacks.\n\nTo install: `npm install bloomxx`\n\n[![Build Status](https://secure.travis-ci.org/ceejbot/xx-bloom.png)](http://travis-ci.org/ceejbot/xx-bloom)\n\n## Usage\n\n### BloomFilter\n\nTo create a filter, pass an options hash to the constructor:\n\n```javascript\nvar options =\n{\n\tbits: 1024,\n\thashes: 7,\n\tseeds: [1, 2, 3, 4, 5, 6, 7]\n};\nfilter = new BloomFilter(options);\n```\n\nYou can pass in seeds for the hash functions if you like, or they'll be randomly generated. Seeds must be integers.\n\n### createOptimal()\n\nTo create a filter optimized for the number of items you'll be storing and a desired error rate:\n\n`filter = BloomFilter.createOptimal(estimatedItemCount, errorRate);`\n\nThe error rate parameter is optional. It defaults to 0.005, or a 0.5% rate.\n\n### add()\n\n`filter.add('cat');`\n\nAdds the given item to the filter. Can also accept buffers and arrays containing strings or buffers:\n\n`filter.add(['cat', 'dog', 'coati', 'red panda']);`\n\n### has()\n\nTo test for membership:\n\n`filter.has('dog');`\n\n### clear()\n\nTo clear the filter:\n\n`filter.clear();`\n\n### CountingFilter\n\nUses about 8 times as much space as the regular filter. Basic usage is exactly the same as the plain Bloom filter:\n\n```javascript\nfilter = new CountingFilter({ hashes: 8, bits: 1024 });`\nfilter2 = CountingFilter.createOptimal(estimatedItemCount, optionalErrorRate);\n```\n\nAdd a list, test for membership, then remove:\n\n```javascript\nfilter.add(['cat', 'dog', 'coati', 'red panda']);\nfilter.has('cat'); // returns true\nfilter.remove('cat');\nfilter.has('cat'); // returns false most of the time\n```\n\nThe counting filter tracks its overflow count in `filter.overflow`. Overflow will be non-zero if any bit has been set more than 255 times. Once the filter has overflowed, removing items is no longer reliable.\n\nCheck for overflow:\n\n```javascript\nfilter.hasOverflowed(); // returns boolean\nfilter.overflow; // integer count of number of times overflow occurred\n```\n\n### RedisFilter\n\nThis is a plain vanilla bloom filter backed by redis. Its api is asychronous.\n\n```javascript\nRedisFilter.createOrRead({\n\t\tkey: 'cats', // the key used to store data in redis; will also set 'cats:meta'\n\t\tbits: 1024,  // filter size in bits\n\t\thashes: 8,   // number of hash functions\n\t\tredis: redis.createClient(port, host)  // redis client to use\n\t}, function(err, filter)\n\t{\n\t\tfilter.add(['cat', 'jaguar', 'lion', 'tiger', 'leopard'], function(err)\n\t\t{\n\t\t\tfilter.has('caracal', function(err, result)\n\t\t\t{\n\t\t\t\tassert(result === false);\n\t\t\t});\n\t\t});\n\t});\n```\n\nThe options hash can also specify `host` and `port`, which will be used to create a redis client. `createOrRead()` will attempt to find a filter saved at the given key and create one if it isn't found.\n\n### createOptimal(itemCount, errorRate, options)\n\nReturns a filter sized for the given item count and desired error rate, with other options as specified in the `options` hash.\n\n### clear(function(err) {})\n\nClear all bits.\n\n### del(function(err) {})\n\nDelete the filter from redis.\n\n## Licence \n\nMIT.\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/ceejbot/xx-bloom",
  "_id": "bloomxx@0.0.2",
  "dist": {
    "shasum": "5266101f66c7c52b79b5b34a44eaddbe0595c864"
  },
  "_from": "bloomxx@*",
  "_resolved": "http://r.cnpmjs.org/bloomxx/download/bloomxx-0.0.2.tgz"
}
